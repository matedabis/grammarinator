# Generated by Grammarinator 18.10r

from itertools import chain
from grammarinator.runtime import *

import ECMAScriptUnlexer


class ECMAScriptUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(ECMAScriptUnparser, self).__init__()
        self.unlexer = unlexer
        self.set_options()

    @depthcontrol
    def program(self):
        current = self.create_node(UnparserRule(name='program'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.sourceElements()

        current += self.unlexer.EOF()
        return current
    program.min_depth = 1

    @depthcontrol
    def sourceElements(self):
        current = self.create_node(UnparserRule(name='sourceElements'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.sourceElement()

        return current
    sourceElements.min_depth = 3

    @depthcontrol
    def sourceElement(self):
        current = self.create_node(UnparserRule(name='sourceElement'))
        choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_585', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_585', choice)] = self.unlexer.weights.get(('alt_585', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.statement()
        elif choice == 1:
            current += self.functionDeclaration()
        return current
    sourceElement.min_depth = 2

    @depthcontrol
    def statement(self):
        current = self.create_node(UnparserRule(name='statement'))
        choice = self.choice([0 if [1, 5, 2, 5, 5, 4, 2, 2, 2, 5, 3, 5, 5, 3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_588', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_588', choice)] = self.unlexer.weights.get(('alt_588', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.block()
        elif choice == 1:
            current += self.variableStatement()
        elif choice == 2:
            current += self.emptyStatement()
        elif choice == 3:
            current += self.expressionStatement()
        elif choice == 4:
            current += self.ifStatement()
        elif choice == 5:
            current += self.iterationStatement()
        elif choice == 6:
            current += self.continueStatement()
        elif choice == 7:
            current += self.breakStatement()
        elif choice == 8:
            current += self.returnStatement()
        elif choice == 9:
            current += self.withStatement()
        elif choice == 10:
            current += self.labelledStatement()
        elif choice == 11:
            current += self.switchStatement()
        elif choice == 12:
            current += self.throwStatement()
        elif choice == 13:
            current += self.tryStatement()
        elif choice == 14:
            current += self.debuggerStatement()
        return current
    statement.min_depth = 1

    @depthcontrol
    def block(self):
        current = self.create_node(UnparserRule(name='block'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.statementList()

        current += self.create_node(UnlexerRule(src='}'))
        return current
    block.min_depth = 0

    @depthcontrol
    def statementList(self):
        current = self.create_node(UnparserRule(name='statementList'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.statement()

        return current
    statementList.min_depth = 2

    @depthcontrol
    def variableStatement(self):
        current = self.create_node(UnparserRule(name='variableStatement'))
        current += self.unlexer.Var()
        current += self.variableDeclarationList()
        current += self.eos()
        return current
    variableStatement.min_depth = 4

    @depthcontrol
    def variableDeclarationList(self):
        current = self.create_node(UnparserRule(name='variableDeclarationList'))
        current += self.variableDeclaration()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.variableDeclaration()

        return current
    variableDeclarationList.min_depth = 3

    @depthcontrol
    def variableDeclaration(self):
        current = self.create_node(UnparserRule(name='variableDeclaration'))
        current += self.unlexer.Identifier()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.initialiser()

        return current
    variableDeclaration.min_depth = 2

    @depthcontrol
    def initialiser(self):
        current = self.create_node(UnparserRule(name='initialiser'))
        current += self.create_node(UnlexerRule(src='='))
        current += self.singleExpression()
        return current
    initialiser.min_depth = 3

    @depthcontrol
    def emptyStatement(self):
        current = self.create_node(UnparserRule(name='emptyStatement'))
        current += self.unlexer.SemiColon()
        return current
    emptyStatement.min_depth = 1

    @depthcontrol
    def expressionStatement(self):
        current = self.create_node(UnparserRule(name='expressionStatement'))
        current += self.expressionSequence()
        current += self.eos()
        return current
    expressionStatement.min_depth = 4

    @depthcontrol
    def ifStatement(self):
        current = self.create_node(UnparserRule(name='ifStatement'))
        current += self.unlexer.If()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.Else()
                current += self.statement()

        return current
    ifStatement.min_depth = 4

    @depthcontrol
    def iterationStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement'))
        choice = self.choice([0 if [5, 5, 3, 5, 5, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_614', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_614', choice)] = self.unlexer.weights.get(('alt_614', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.iterationStatement_DoStatement()
        elif choice == 1:
            current = self.iterationStatement_WhileStatement()
        elif choice == 2:
            current = self.iterationStatement_ForStatement()
        elif choice == 3:
            current = self.iterationStatement_ForVarStatement()
        elif choice == 4:
            current = self.iterationStatement_ForInStatement()
        elif choice == 5:
            current = self.iterationStatement_ForVarInStatement()
        return current
    iterationStatement.min_depth = 3

    @depthcontrol
    def iterationStatement_DoStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_DoStatement'))
        current += self.unlexer.Do()
        current += self.statement()
        current += self.unlexer.While()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.eos()
        return current
    iterationStatement_DoStatement.min_depth = 4

    @depthcontrol
    def iterationStatement_WhileStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_WhileStatement'))
        current += self.unlexer.While()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    iterationStatement_WhileStatement.min_depth = 4

    @depthcontrol
    def iterationStatement_ForStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_ForStatement'))
        current += self.unlexer.For()
        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.create_node(UnlexerRule(src=';'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.create_node(UnlexerRule(src=';'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    iterationStatement_ForStatement.min_depth = 2

    @depthcontrol
    def iterationStatement_ForVarStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_ForVarStatement'))
        current += self.unlexer.For()
        current += self.create_node(UnlexerRule(src='('))
        current += self.unlexer.Var()
        current += self.variableDeclarationList()
        current += self.create_node(UnlexerRule(src=';'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.create_node(UnlexerRule(src=';'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    iterationStatement_ForVarStatement.min_depth = 4

    @depthcontrol
    def iterationStatement_ForInStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_ForInStatement'))
        current += self.unlexer.For()
        current += self.create_node(UnlexerRule(src='('))
        current += self.singleExpression()
        current += self.unlexer.In()
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    iterationStatement_ForInStatement.min_depth = 4

    @depthcontrol
    def iterationStatement_ForVarInStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_ForVarInStatement'))
        current += self.unlexer.For()
        current += self.create_node(UnlexerRule(src='('))
        current += self.unlexer.Var()
        current += self.variableDeclaration()
        current += self.unlexer.In()
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    iterationStatement_ForVarInStatement.min_depth = 4

    @depthcontrol
    def continueStatement(self):
        current = self.create_node(UnparserRule(name='continueStatement'))
        current += self.unlexer.Continue()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.Identifier()

        current += self.eos()
        return current
    continueStatement.min_depth = 1

    @depthcontrol
    def breakStatement(self):
        current = self.create_node(UnparserRule(name='breakStatement'))
        current += self.unlexer.Break()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.Identifier()

        current += self.eos()
        return current
    breakStatement.min_depth = 1

    @depthcontrol
    def returnStatement(self):
        current = self.create_node(UnparserRule(name='returnStatement'))
        current += self.unlexer.Return()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.eos()
        return current
    returnStatement.min_depth = 1

    @depthcontrol
    def withStatement(self):
        current = self.create_node(UnparserRule(name='withStatement'))
        current += self.unlexer.With()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    withStatement.min_depth = 4

    @depthcontrol
    def switchStatement(self):
        current = self.create_node(UnparserRule(name='switchStatement'))
        current += self.unlexer.Switch()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.caseBlock()
        return current
    switchStatement.min_depth = 4

    @depthcontrol
    def caseBlock(self):
        current = self.create_node(UnparserRule(name='caseBlock'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                current += self.caseClauses()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.defaultClause()
                if self.unlexer.max_depth >= 6:
                    for _ in self.zero_or_one():
                        current += self.caseClauses()


        current += self.create_node(UnlexerRule(src='}'))
        return current
    caseBlock.min_depth = 0

    @depthcontrol
    def caseClauses(self):
        current = self.create_node(UnparserRule(name='caseClauses'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.caseClause()

        return current
    caseClauses.min_depth = 5

    @depthcontrol
    def caseClause(self):
        current = self.create_node(UnparserRule(name='caseClause'))
        current += self.unlexer.Case()
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=':'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.statementList()

        return current
    caseClause.min_depth = 4

    @depthcontrol
    def defaultClause(self):
        current = self.create_node(UnparserRule(name='defaultClause'))
        current += self.unlexer.Default()
        current += self.create_node(UnlexerRule(src=':'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.statementList()

        return current
    defaultClause.min_depth = 1

    @depthcontrol
    def labelledStatement(self):
        current = self.create_node(UnparserRule(name='labelledStatement'))
        current += self.unlexer.Identifier()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.statement()
        return current
    labelledStatement.min_depth = 2

    @depthcontrol
    def throwStatement(self):
        current = self.create_node(UnparserRule(name='throwStatement'))
        current += self.unlexer.Throw()
        current += self.expressionSequence()
        current += self.eos()
        return current
    throwStatement.min_depth = 4

    @depthcontrol
    def tryStatement(self):
        current = self.create_node(UnparserRule(name='tryStatement'))
        choice = self.choice([0 if [3, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_659', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_659', choice)] = self.unlexer.weights.get(('alt_659', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Try()
            current += self.block()
            current += self.catchProduction()
        elif choice == 1:
            current += self.unlexer.Try()
            current += self.block()
            current += self.finallyProduction()
        elif choice == 2:
            current += self.unlexer.Try()
            current += self.block()
            current += self.catchProduction()
            current += self.finallyProduction()
        return current
    tryStatement.min_depth = 2

    @depthcontrol
    def catchProduction(self):
        current = self.create_node(UnparserRule(name='catchProduction'))
        current += self.unlexer.Catch()
        current += self.create_node(UnlexerRule(src='('))
        current += self.unlexer.Identifier()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.block()
        return current
    catchProduction.min_depth = 2

    @depthcontrol
    def finallyProduction(self):
        current = self.create_node(UnparserRule(name='finallyProduction'))
        current += self.unlexer.Finally()
        current += self.block()
        return current
    finallyProduction.min_depth = 1

    @depthcontrol
    def debuggerStatement(self):
        current = self.create_node(UnparserRule(name='debuggerStatement'))
        current += self.unlexer.Debugger()
        current += self.eos()
        return current
    debuggerStatement.min_depth = 1

    @depthcontrol
    def functionDeclaration(self):
        current = self.create_node(UnparserRule(name='functionDeclaration'))
        current += self.unlexer.Function()
        current += self.unlexer.Identifier()
        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.formalParameterList()

        current += self.create_node(UnlexerRule(src=')'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.functionBody()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    functionDeclaration.min_depth = 2

    @depthcontrol
    def formalParameterList(self):
        current = self.create_node(UnparserRule(name='formalParameterList'))
        current += self.unlexer.Identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.unlexer.Identifier()

        return current
    formalParameterList.min_depth = 2

    @depthcontrol
    def functionBody(self):
        current = self.create_node(UnparserRule(name='functionBody'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.sourceElements()

        return current
    functionBody.min_depth = 0

    @depthcontrol
    def arrayLiteral(self):
        current = self.create_node(UnparserRule(name='arrayLiteral'))
        current += self.create_node(UnlexerRule(src='['))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.elementList()

        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src=','))

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.elision()

        current += self.create_node(UnlexerRule(src=']'))
        return current
    arrayLiteral.min_depth = 0

    @depthcontrol
    def elementList(self):
        current = self.create_node(UnparserRule(name='elementList'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.elision()

        current += self.singleExpression()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.elision()

                current += self.singleExpression()

        return current
    elementList.min_depth = 3

    @depthcontrol
    def elision(self):
        current = self.create_node(UnparserRule(name='elision'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=','))

        return current
    elision.min_depth = 0

    @depthcontrol
    def objectLiteral(self):
        current = self.create_node(UnparserRule(name='objectLiteral'))
        choice = self.choice([0 if [0, 6][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_684', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_684', choice)] = self.unlexer.weights.get(('alt_684', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='{'))
            current += self.create_node(UnlexerRule(src='}'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='{'))
            current += self.propertyNameAndValueList()
            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src=','))

            current += self.create_node(UnlexerRule(src='}'))
        return current
    objectLiteral.min_depth = 0

    @depthcontrol
    def propertyNameAndValueList(self):
        current = self.create_node(UnparserRule(name='propertyNameAndValueList'))
        current += self.propertyAssignment()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.propertyAssignment()

        return current
    propertyNameAndValueList.min_depth = 5

    @depthcontrol
    def propertyAssignment(self):
        current = self.create_node(UnparserRule(name='propertyAssignment'))
        choice = self.choice([0 if [4, 4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_695', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_695', choice)] = self.unlexer.weights.get(('alt_695', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.propertyAssignment_PropertyExpressionAssignment()
        elif choice == 1:
            current = self.propertyAssignment_PropertyGetter()
        elif choice == 2:
            current = self.propertyAssignment_PropertySetter()
        return current
    propertyAssignment.min_depth = 4

    @depthcontrol
    def propertyAssignment_PropertyExpressionAssignment(self):
        current = self.create_node(UnparserRule(name='propertyAssignment_PropertyExpressionAssignment'))
        current += self.propertyName()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.singleExpression()
        return current
    propertyAssignment_PropertyExpressionAssignment.min_depth = 3

    @depthcontrol
    def propertyAssignment_PropertyGetter(self):
        current = self.create_node(UnparserRule(name='propertyAssignment_PropertyGetter'))
        current += self.getter()
        current += self.create_node(UnlexerRule(src='('))
        current += self.create_node(UnlexerRule(src=')'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.functionBody()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    propertyAssignment_PropertyGetter.min_depth = 3

    @depthcontrol
    def propertyAssignment_PropertySetter(self):
        current = self.create_node(UnparserRule(name='propertyAssignment_PropertySetter'))
        current += self.setter()
        current += self.create_node(UnlexerRule(src='('))
        current += self.propertySetParameterList()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.functionBody()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    propertyAssignment_PropertySetter.min_depth = 3

    @depthcontrol
    def propertyName(self):
        current = self.create_node(UnparserRule(name='propertyName'))
        choice = self.choice([0 if [3, 1, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_708', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_708', choice)] = self.unlexer.weights.get(('alt_708', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.identifierName()
        elif choice == 1:
            current += self.unlexer.StringLiteral()
        elif choice == 2:
            current += self.numericLiteral()
        return current
    propertyName.min_depth = 1

    @depthcontrol
    def propertySetParameterList(self):
        current = self.create_node(UnparserRule(name='propertySetParameterList'))
        current += self.unlexer.Identifier()
        return current
    propertySetParameterList.min_depth = 2

    @depthcontrol
    def arguments(self):
        current = self.create_node(UnparserRule(name='arguments'))
        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.argumentList()

        current += self.create_node(UnlexerRule(src=')'))
        return current
    arguments.min_depth = 0

    @depthcontrol
    def argumentList(self):
        current = self.create_node(UnparserRule(name='argumentList'))
        current += self.singleExpression()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.singleExpression()

        return current
    argumentList.min_depth = 3

    @depthcontrol
    def expressionSequence(self):
        current = self.create_node(UnparserRule(name='expressionSequence'))
        current += self.singleExpression()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.singleExpression()

        return current
    expressionSequence.min_depth = 3

    @depthcontrol
    def singleExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression'))
        choice = self.choice([0 if [2, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 3, 3, 2, 2, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_719', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_719', choice)] = self.unlexer.weights.get(('alt_719', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.singleExpression_FunctionExpression()
        elif choice == 1:
            current = self.singleExpression_MemberIndexExpression()
        elif choice == 2:
            current = self.singleExpression_MemberDotExpression()
        elif choice == 3:
            current = self.singleExpression_ArgumentsExpression()
        elif choice == 4:
            current = self.singleExpression_NewExpression()
        elif choice == 5:
            current = self.singleExpression_PostIncrementExpression()
        elif choice == 6:
            current = self.singleExpression_PostDecreaseExpression()
        elif choice == 7:
            current = self.singleExpression_DeleteExpression()
        elif choice == 8:
            current = self.singleExpression_VoidExpression()
        elif choice == 9:
            current = self.singleExpression_TypeofExpression()
        elif choice == 10:
            current = self.singleExpression_PreIncrementExpression()
        elif choice == 11:
            current = self.singleExpression_PreDecreaseExpression()
        elif choice == 12:
            current = self.singleExpression_UnaryPlusExpression()
        elif choice == 13:
            current = self.singleExpression_UnaryMinusExpression()
        elif choice == 14:
            current = self.singleExpression_BitNotExpression()
        elif choice == 15:
            current = self.singleExpression_NotExpression()
        elif choice == 16:
            current = self.singleExpression_MultiplicativeExpression()
        elif choice == 17:
            current = self.singleExpression_AdditiveExpression()
        elif choice == 18:
            current = self.singleExpression_BitShiftExpression()
        elif choice == 19:
            current = self.singleExpression_RelationalExpression()
        elif choice == 20:
            current = self.singleExpression_InstanceofExpression()
        elif choice == 21:
            current = self.singleExpression_InExpression()
        elif choice == 22:
            current = self.singleExpression_EqualityExpression()
        elif choice == 23:
            current = self.singleExpression_BitAndExpression()
        elif choice == 24:
            current = self.singleExpression_BitXOrExpression()
        elif choice == 25:
            current = self.singleExpression_BitOrExpression()
        elif choice == 26:
            current = self.singleExpression_LogicalAndExpression()
        elif choice == 27:
            current = self.singleExpression_LogicalOrExpression()
        elif choice == 28:
            current = self.singleExpression_TernaryExpression()
        elif choice == 29:
            current = self.singleExpression_AssignmentExpression()
        elif choice == 30:
            current = self.singleExpression_AssignmentOperatorExpression()
        elif choice == 31:
            current = self.singleExpression_ThisExpression()
        elif choice == 32:
            current = self.singleExpression_IdentifierExpression()
        elif choice == 33:
            current = self.singleExpression_LiteralExpression()
        elif choice == 34:
            current = self.singleExpression_ArrayLiteralExpression()
        elif choice == 35:
            current = self.singleExpression_ObjectLiteralExpression()
        elif choice == 36:
            current = self.singleExpression_ParenthesizedExpression()
        return current
    singleExpression.min_depth = 2

    @depthcontrol
    def singleExpression_FunctionExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_FunctionExpression'))
        current += self.unlexer.Function()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.Identifier()

        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.formalParameterList()

        current += self.create_node(UnlexerRule(src=')'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.functionBody()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    singleExpression_FunctionExpression.min_depth = 1

    @depthcontrol
    def singleExpression_MemberIndexExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_MemberIndexExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='['))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=']'))
        return current
    singleExpression_MemberIndexExpression.min_depth = 4

    @depthcontrol
    def singleExpression_MemberDotExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_MemberDotExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='.'))
        current += self.identifierName()
        return current
    singleExpression_MemberDotExpression.min_depth = 3

    @depthcontrol
    def singleExpression_ArgumentsExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ArgumentsExpression'))
        current += self.singleExpression()
        current += self.arguments()
        return current
    singleExpression_ArgumentsExpression.min_depth = 3

    @depthcontrol
    def singleExpression_NewExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_NewExpression'))
        current += self.unlexer.New()
        current += self.singleExpression()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.arguments()

        return current
    singleExpression_NewExpression.min_depth = 3

    @depthcontrol
    def singleExpression_PostIncrementExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_PostIncrementExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='++'))
        return current
    singleExpression_PostIncrementExpression.min_depth = 3

    @depthcontrol
    def singleExpression_PostDecreaseExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_PostDecreaseExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='--'))
        return current
    singleExpression_PostDecreaseExpression.min_depth = 3

    @depthcontrol
    def singleExpression_DeleteExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_DeleteExpression'))
        current += self.unlexer.Delete()
        current += self.singleExpression()
        return current
    singleExpression_DeleteExpression.min_depth = 3

    @depthcontrol
    def singleExpression_VoidExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_VoidExpression'))
        current += self.unlexer.Void()
        current += self.singleExpression()
        return current
    singleExpression_VoidExpression.min_depth = 3

    @depthcontrol
    def singleExpression_TypeofExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_TypeofExpression'))
        current += self.unlexer.Typeof()
        current += self.singleExpression()
        return current
    singleExpression_TypeofExpression.min_depth = 3

    @depthcontrol
    def singleExpression_PreIncrementExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_PreIncrementExpression'))
        current += self.create_node(UnlexerRule(src='++'))
        current += self.singleExpression()
        return current
    singleExpression_PreIncrementExpression.min_depth = 3

    @depthcontrol
    def singleExpression_PreDecreaseExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_PreDecreaseExpression'))
        current += self.create_node(UnlexerRule(src='--'))
        current += self.singleExpression()
        return current
    singleExpression_PreDecreaseExpression.min_depth = 3

    @depthcontrol
    def singleExpression_UnaryPlusExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_UnaryPlusExpression'))
        current += self.create_node(UnlexerRule(src='+'))
        current += self.singleExpression()
        return current
    singleExpression_UnaryPlusExpression.min_depth = 3

    @depthcontrol
    def singleExpression_UnaryMinusExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_UnaryMinusExpression'))
        current += self.create_node(UnlexerRule(src='-'))
        current += self.singleExpression()
        return current
    singleExpression_UnaryMinusExpression.min_depth = 3

    @depthcontrol
    def singleExpression_BitNotExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_BitNotExpression'))
        current += self.create_node(UnlexerRule(src='~'))
        current += self.singleExpression()
        return current
    singleExpression_BitNotExpression.min_depth = 3

    @depthcontrol
    def singleExpression_NotExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_NotExpression'))
        current += self.create_node(UnlexerRule(src='!'))
        current += self.singleExpression()
        return current
    singleExpression_NotExpression.min_depth = 3

    @depthcontrol
    def singleExpression_MultiplicativeExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_MultiplicativeExpression'))
        current += self.singleExpression()
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_775', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_775', choice)] = self.unlexer.weights.get(('alt_775', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='*'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='/'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='%'))
        current += self.singleExpression()
        return current
    singleExpression_MultiplicativeExpression.min_depth = 3

    @depthcontrol
    def singleExpression_AdditiveExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_AdditiveExpression'))
        current += self.singleExpression()
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_782', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_782', choice)] = self.unlexer.weights.get(('alt_782', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='+'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='-'))
        current += self.singleExpression()
        return current
    singleExpression_AdditiveExpression.min_depth = 3

    @depthcontrol
    def singleExpression_BitShiftExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_BitShiftExpression'))
        current += self.singleExpression()
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_787', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_787', choice)] = self.unlexer.weights.get(('alt_787', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='<<'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='>>'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='>>>'))
        current += self.singleExpression()
        return current
    singleExpression_BitShiftExpression.min_depth = 3

    @depthcontrol
    def singleExpression_RelationalExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_RelationalExpression'))
        current += self.singleExpression()
        choice = self.choice([0 if [0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_794', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_794', choice)] = self.unlexer.weights.get(('alt_794', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='<'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='>'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='<='))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='>='))
        current += self.singleExpression()
        return current
    singleExpression_RelationalExpression.min_depth = 3

    @depthcontrol
    def singleExpression_InstanceofExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_InstanceofExpression'))
        current += self.singleExpression()
        current += self.unlexer.Instanceof()
        current += self.singleExpression()
        return current
    singleExpression_InstanceofExpression.min_depth = 3

    @depthcontrol
    def singleExpression_InExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_InExpression'))
        current += self.singleExpression()
        current += self.unlexer.In()
        current += self.singleExpression()
        return current
    singleExpression_InExpression.min_depth = 3

    @depthcontrol
    def singleExpression_EqualityExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_EqualityExpression'))
        current += self.singleExpression()
        choice = self.choice([0 if [0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_803', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_803', choice)] = self.unlexer.weights.get(('alt_803', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='=='))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='!='))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='==='))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='!=='))
        current += self.singleExpression()
        return current
    singleExpression_EqualityExpression.min_depth = 3

    @depthcontrol
    def singleExpression_BitAndExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_BitAndExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='&'))
        current += self.singleExpression()
        return current
    singleExpression_BitAndExpression.min_depth = 3

    @depthcontrol
    def singleExpression_BitXOrExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_BitXOrExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='^'))
        current += self.singleExpression()
        return current
    singleExpression_BitXOrExpression.min_depth = 3

    @depthcontrol
    def singleExpression_BitOrExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_BitOrExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='|'))
        current += self.singleExpression()
        return current
    singleExpression_BitOrExpression.min_depth = 3

    @depthcontrol
    def singleExpression_LogicalAndExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_LogicalAndExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='&&'))
        current += self.singleExpression()
        return current
    singleExpression_LogicalAndExpression.min_depth = 3

    @depthcontrol
    def singleExpression_LogicalOrExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_LogicalOrExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='||'))
        current += self.singleExpression()
        return current
    singleExpression_LogicalOrExpression.min_depth = 3

    @depthcontrol
    def singleExpression_TernaryExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_TernaryExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='?'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.singleExpression()
        return current
    singleExpression_TernaryExpression.min_depth = 3

    @depthcontrol
    def singleExpression_AssignmentExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_AssignmentExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='='))
        current += self.singleExpression()
        return current
    singleExpression_AssignmentExpression.min_depth = 3

    @depthcontrol
    def singleExpression_AssignmentOperatorExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_AssignmentOperatorExpression'))
        current += self.singleExpression()
        current += self.assignmentOperator()
        current += self.singleExpression()
        return current
    singleExpression_AssignmentOperatorExpression.min_depth = 3

    @depthcontrol
    def singleExpression_ThisExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ThisExpression'))
        current += self.unlexer.This()
        return current
    singleExpression_ThisExpression.min_depth = 1

    @depthcontrol
    def singleExpression_IdentifierExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_IdentifierExpression'))
        current += self.unlexer.Identifier()
        return current
    singleExpression_IdentifierExpression.min_depth = 2

    @depthcontrol
    def singleExpression_LiteralExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_LiteralExpression'))
        current += self.literal()
        return current
    singleExpression_LiteralExpression.min_depth = 2

    @depthcontrol
    def singleExpression_ArrayLiteralExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ArrayLiteralExpression'))
        current += self.arrayLiteral()
        return current
    singleExpression_ArrayLiteralExpression.min_depth = 1

    @depthcontrol
    def singleExpression_ObjectLiteralExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ObjectLiteralExpression'))
        current += self.objectLiteral()
        return current
    singleExpression_ObjectLiteralExpression.min_depth = 1

    @depthcontrol
    def singleExpression_ParenthesizedExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ParenthesizedExpression'))
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        return current
    singleExpression_ParenthesizedExpression.min_depth = 4

    @depthcontrol
    def assignmentOperator(self):
        current = self.create_node(UnparserRule(name='assignmentOperator'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_822', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_822', choice)] = self.unlexer.weights.get(('alt_822', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='*='))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='/='))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='%='))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='+='))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='-='))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='<<='))
        elif choice == 6:
            current += self.create_node(UnlexerRule(src='>>='))
        elif choice == 7:
            current += self.create_node(UnlexerRule(src='>>>='))
        elif choice == 8:
            current += self.create_node(UnlexerRule(src='&='))
        elif choice == 9:
            current += self.create_node(UnlexerRule(src='^='))
        elif choice == 10:
            current += self.create_node(UnlexerRule(src='|='))
        return current
    assignmentOperator.min_depth = 0

    @depthcontrol
    def literal(self):
        current = self.create_node(UnparserRule(name='literal'))
        choice = self.choice([0 if [1, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_845', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_845', choice)] = self.unlexer.weights.get(('alt_845', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            choice = self.choice([0 if [1, 1, 1, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_848', i), 1) for i, w in enumerate([1, 1, 1, 1])])
            self.unlexer.weights[('alt_848', choice)] = self.unlexer.weights.get(('alt_848', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.NullLiteral()
            elif choice == 1:
                current += self.unlexer.BooleanLiteral()
            elif choice == 2:
                current += self.unlexer.StringLiteral()
            elif choice == 3:
                current += self.unlexer.RegularExpressionLiteral()
        elif choice == 1:
            current += self.numericLiteral()
        return current
    literal.min_depth = 1

    @depthcontrol
    def numericLiteral(self):
        current = self.create_node(UnparserRule(name='numericLiteral'))
        choice = self.choice([0 if [2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_853', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_853', choice)] = self.unlexer.weights.get(('alt_853', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.DecimalLiteral()
        elif choice == 1:
            current += self.unlexer.HexIntegerLiteral()
        elif choice == 2:
            current += self.unlexer.OctalIntegerLiteral()
        return current
    numericLiteral.min_depth = 2

    @depthcontrol
    def identifierName(self):
        current = self.create_node(UnparserRule(name='identifierName'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_857', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_857', choice)] = self.unlexer.weights.get(('alt_857', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Identifier()
        elif choice == 1:
            current += self.reservedWord()
        return current
    identifierName.min_depth = 2

    @depthcontrol
    def reservedWord(self):
        current = self.create_node(UnparserRule(name='reservedWord'))
        choice = self.choice([0 if [2, 2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_860', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_860', choice)] = self.unlexer.weights.get(('alt_860', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.keyword()
        elif choice == 1:
            current += self.futureReservedWord()
        elif choice == 2:
            choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_864', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_864', choice)] = self.unlexer.weights.get(('alt_864', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.NullLiteral()
            elif choice == 1:
                current += self.unlexer.BooleanLiteral()
        return current
    reservedWord.min_depth = 1

    @depthcontrol
    def keyword(self):
        current = self.create_node(UnparserRule(name='keyword'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_867', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_867', choice)] = self.unlexer.weights.get(('alt_867', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Break()
        elif choice == 1:
            current += self.unlexer.Do()
        elif choice == 2:
            current += self.unlexer.Instanceof()
        elif choice == 3:
            current += self.unlexer.Typeof()
        elif choice == 4:
            current += self.unlexer.Case()
        elif choice == 5:
            current += self.unlexer.Else()
        elif choice == 6:
            current += self.unlexer.New()
        elif choice == 7:
            current += self.unlexer.Var()
        elif choice == 8:
            current += self.unlexer.Catch()
        elif choice == 9:
            current += self.unlexer.Finally()
        elif choice == 10:
            current += self.unlexer.Return()
        elif choice == 11:
            current += self.unlexer.Void()
        elif choice == 12:
            current += self.unlexer.Continue()
        elif choice == 13:
            current += self.unlexer.For()
        elif choice == 14:
            current += self.unlexer.Switch()
        elif choice == 15:
            current += self.unlexer.While()
        elif choice == 16:
            current += self.unlexer.Debugger()
        elif choice == 17:
            current += self.unlexer.Function()
        elif choice == 18:
            current += self.unlexer.This()
        elif choice == 19:
            current += self.unlexer.With()
        elif choice == 20:
            current += self.unlexer.Default()
        elif choice == 21:
            current += self.unlexer.If()
        elif choice == 22:
            current += self.unlexer.Throw()
        elif choice == 23:
            current += self.unlexer.Delete()
        elif choice == 24:
            current += self.unlexer.In()
        elif choice == 25:
            current += self.unlexer.Try()
        return current
    keyword.min_depth = 1

    @depthcontrol
    def futureReservedWord(self):
        current = self.create_node(UnparserRule(name='futureReservedWord'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_894', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_894', choice)] = self.unlexer.weights.get(('alt_894', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Class()
        elif choice == 1:
            current += self.unlexer.Enum()
        elif choice == 2:
            current += self.unlexer.Extends()
        elif choice == 3:
            current += self.unlexer.Super()
        elif choice == 4:
            current += self.unlexer.Const()
        elif choice == 5:
            current += self.unlexer.Export()
        elif choice == 6:
            current += self.unlexer.Import()
        elif choice == 7:
            current += self.unlexer.Implements()
        elif choice == 8:
            current += self.unlexer.Let()
        elif choice == 9:
            current += self.unlexer.Private()
        elif choice == 10:
            current += self.unlexer.Public()
        elif choice == 11:
            current += self.unlexer.Interface()
        elif choice == 12:
            current += self.unlexer.Package()
        elif choice == 13:
            current += self.unlexer.Protected()
        elif choice == 14:
            current += self.unlexer.Static()
        elif choice == 15:
            current += self.unlexer.Yield()
        return current
    futureReservedWord.min_depth = 1

    @depthcontrol
    def getter(self):
        current = self.create_node(UnparserRule(name='getter'))
        current += self.unlexer.Identifier()
        current += self.propertyName()
        return current
    getter.min_depth = 2

    @depthcontrol
    def setter(self):
        current = self.create_node(UnparserRule(name='setter'))
        current += self.unlexer.Identifier()
        current += self.propertyName()
        return current
    setter.min_depth = 2

    @depthcontrol
    def eos(self):
        current = self.create_node(UnparserRule(name='eos'))
        choice = self.choice([0 if [1, 1, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_911', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_911', choice)] = self.unlexer.weights.get(('alt_911', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SemiColon()
        elif choice == 1:
            current += self.unlexer.EOF()
        elif choice == 2:
            pass
        elif choice == 3:
            pass
        return current
    eos.min_depth = 0

    @depthcontrol
    def eof(self):
        current = self.create_node(UnparserRule(name='eof'))
        current += self.unlexer.EOF()
        return current
    eof.min_depth = 1

    default_rule = program

