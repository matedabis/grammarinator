# Generated by Grammarinator 18.10r

from itertools import chain
from grammarinator.runtime import *

charset_0 = list(chain(range(49, 58)))
charset_1 = list(chain(range(48, 58)))


class singleExpressionUnlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(singleExpressionUnlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown
        self.set_options()

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def DecimalIntegerLiteral(self):
        current = self.create_node(UnlexerRule(name='DecimalIntegerLiteral'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_0', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_0', choice)] = self.unlexer.weights.get(('alt_0', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='0'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=self.char_from_list(charset_0)))
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.DecimalDigit()

        return current
    DecimalIntegerLiteral.min_depth = 0

    @depthcontrol
    def DecimalDigit(self):
        current = self.create_node(UnlexerRule(name='DecimalDigit'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_1)))
        return current
    DecimalDigit.min_depth = 0

