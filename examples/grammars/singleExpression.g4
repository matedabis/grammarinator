/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 by Bart Kiers
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
grammar singleExpression;

@parser::members {

    /**
     * Returns {@code true} iff on the current index of the parser's
     * token stream a token of the given {@code type} exists on the
     * {@code HIDDEN} channel.
     *
     * @param type
     *         the type of the token on the {@code HIDDEN} channel
     *         to check.
     *
     * @return {@code true} iff on the current index of the parser's
     * token stream a token of the given {@code type} exists on the
     * {@code HIDDEN} channel.
     */
    private boolean here(final int type) {

        // Get the token ahead of the current index.
        int possibleIndexEosToken = this.getCurrentToken().getTokenIndex() - 1;
        Token ahead = _input.get(possibleIndexEosToken);

        // Check if the token resides on the HIDDEN channel and if it's of the
        // provided type.
        return (ahead.getChannel() == Lexer.HIDDEN) && (ahead.getType() == type);
    }

    /**
     * Returns {@code true} iff on the current index of the parser's
     * token stream a token exists on the {@code HIDDEN} channel which
     * either is a line terminator, or is a multi line comment that
     * contains a line terminator.
     *
     * @return {@code true} iff on the current index of the parser's
     * token stream a token exists on the {@code HIDDEN} channel which
     * either is a line terminator, or is a multi line comment that
     * contains a line terminator.
     */
    private boolean lineTerminatorAhead() {

        // Get the token ahead of the current index.
        int possibleIndexEosToken = this.getCurrentToken().getTokenIndex() - 1;
        Token ahead = _input.get(possibleIndexEosToken);

        if (ahead.getChannel() != Lexer.HIDDEN) {
            // We're only interested in tokens on the HIDDEN channel.
            return false;
        }

        if (ahead.getType() == LineTerminator) {
            // There is definitely a line terminator ahead.
            return true;
        }

        if (ahead.getType() == WhiteSpaces) {
            // Get the token ahead of the current whitespaces.
            possibleIndexEosToken = this.getCurrentToken().getTokenIndex() - 2;
            ahead = _input.get(possibleIndexEosToken);
        }

        // Get the token's text and type.
        String text = ahead.getText();
        int type = ahead.getType();

        // Check if the token is, or contains a line terminator.
        return (type == MultiLineComment && (text.contains("\r") || text.contains("\n"))) ||
                (type == LineTerminator);
    }
}

@lexer::members {

    // A flag indicating if the lexer should operate in strict mode.
    // When set to true, FutureReservedWords are tokenized, when false,
    // an octal literal can be tokenized.
    private boolean strictMode = true;

    // The most recently produced token.
    private Token lastToken = null;

    /**
     * Returns {@code true} iff the lexer operates in strict mode.
     *
     * @return {@code true} iff the lexer operates in strict mode.
     */
    public boolean getStrictMode() {
        return this.strictMode;
    }

    /**
     * Sets whether the lexer operates in strict mode or not.
     *
     * @param strictMode
     *         the flag indicating the lexer operates in strict mode or not.
     */
    public void setStrictMode(boolean strictMode) {
        this.strictMode = strictMode;
    }

    /**
     * Return the next token from the character stream and records this last
     * token in case it resides on the default channel. This recorded token
     * is used to determine when the lexer could possibly match a regex
     * literal.
     *
     * @return the next token from the character stream.
     */
    @Override
    public Token nextToken() {

        // Get the next token.
        Token next = super.nextToken();

        if (next.getChannel() == Token.DEFAULT_CHANNEL) {
            // Keep track of the last token on the default channel.
            this.lastToken = next;
        }

        return next;
    }

    /**
     * Returns {@code true} iff the lexer can match a regex literal.
     *
     * @return {@code true} iff the lexer can match a regex literal.
     */
    private boolean isRegexPossible() {

        if (this.lastToken == null) {
            // No token has been produced yet: at the start of the input,
            // no division is possible, so a regex literal _is_ possible.
            return true;
        }

        switch (this.lastToken.getType()) {
            case Identifier:
            case NullLiteral:
            case BooleanLiteral:
            case This:
            case CloseBracket:
            case CloseParen:
            case OctalIntegerLiteral:
            case DecimalLiteral:
            case HexIntegerLiteral:
            case StringLiteral:
            case PlusPlus:
            case MinusMinus:
                // After any of the tokens above, no regex literal can follow.
                return false;
            default:
                // In all other cases, a regex literal _is_ possible.
                return true;
        }
    }
}

grammar singleExpression;

singleExpression
 : singleExpression '+' singleExpression                                                   /// UnaryPlusExpression
 | singleExpression '-' singleExpression                                                   /// UnaryMinusExpression
 | '(' '~' singleExpression ')'                                               /// BitNotExpression
 | '(' '!' singleExpression ')'                                               /// NotExpression
 | singleExpression '*' singleExpression
 | singleExpression '/' singleExpression
 | singleExpression '%' singleExpression                                      /// MultiplicativeExpression
 | singleExpression '+' singleExpression
 | singleExpression '-' singleExpression                                      /// AdditiveExpression
 | singleExpression '<<' singleExpression
 | singleExpression '>>' singleExpression
 | singleExpression '>>>' singleExpression              /// BitShiftExpression
 | singleExpression '<'  singleExpression          /// RelationalExpression
 | singleExpression '>'  singleExpression          /// RelationalExpression
 | singleExpression '<=' singleExpression          /// RelationalExpression
 | singleExpression '>=' singleExpression          /// RelationalExpression
 | singleExpression '==' singleExpression
 | singleExpression '!=' singleExpression
 | singleExpression '===' singleExpression
 | singleExpression '!==' singleExpression      /// EqualityExpression
 | singleExpression '&' singleExpression                                      /// BitAndExpression
 | singleExpression '^' singleExpression                                      /// BitXOrExpression
 | singleExpression '|' singleExpression                                      /// BitOrExpression
 | singleExpression '&&' singleExpression                                     /// LogicalAndExpression
 | singleExpression '||' singleExpression                                     /// LogicalOrExpression
 | '(' singleExpression ')'                                                   /// ParenthesizedExpression
 | DecimalIntegerLiteral
 | DecimalIntegerLiteral
 | DecimalIntegerLiteral
 | DecimalIntegerLiteral
 | DecimalIntegerLiteral
 | DecimalIntegerLiteral
 | 'null'
 | 'true'
 | 'false'
 | 'undefined'
 ;

 fragment DecimalIntegerLiteral
 : '0'
 | [1-9] DecimalDigit* DecimalDigit* DecimalDigit*
 ;


 fragment DecimalDigit
 : [0-9]
 ;
